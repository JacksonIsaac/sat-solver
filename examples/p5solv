#!/usr/bin/perl -w

use POSIX;
use Fcntl;
use Config::IniFiles;
use File::FnMatch;
use Data::Dumper;
use solv;
use Devel::Peek;
use FileHandle;
use strict;

package Repo::generic;

sub new {
  my ($class, $attr) = @_;
  my $r = { %$attr };
  return bless $r, $class;
}

sub cachepath {
  my ($self, $ext) = @_;
  my $path = $self->{'alias'};
  $path =~ s/^\./_/s;
  $path .= $ext ? "_$ext.solvx" : '.solv';
  $path =~ s/\//_/gs;
  return "/var/cache/solv/$path";
}

sub load {
  my ($self, $pool) = @_;
  $self->{'handle'} = $pool->add_repo($self->{'alias'});
  $self->{'handle'}->{'appdata'} = $self;
  $self->{'handle'}->{'priority'} = 99 - $self->{'priority'};
  $self->{'cookie'} = '';
  $self->usecachedrepo();
}

sub download {
  my ($self, $file, $uncompress, $chksum, $markincomplete) = @_;
  if (!$self->{'baseurl'}) {
    print "$self->{'alias'}: no baseurl\n";
    return undef;
  }
  my $url = $self->{'baseurl'};
  $url =~ s/\/$//;
  $url .= "/$file";
  open(my $f, '+>', undef) || die;
  fcntl($f, Fcntl::F_SETFD, 0);
  my $st = system('curl', '-f', '-s', '-L', '-o', "/dev/fd/".fileno($f), '--', $url);
  if (POSIX::lseek(fileno($f), 0, POSIX::SEEK_END) == 0 && ($st == 0 || !$chksum)) {
    return undef;
  }
  POSIX::lseek(fileno($f), 0, POSIX::SEEK_SET);
  if ($st) {
    print "$file: download error #$st\n";
    $self->{'incomplete'} = 1 if $markincomplete;
    return undef;
  }
  if ($chksum) {
    my $fchksum = solv::Chksum->new($chksum->{'type'});
    $fchksum->add_fd(fileno($f));
    if (!$fchksum->matches($chksum)) {
      print "$file: checksum error\n";
      $self->{'incomplete'} = 1 if $markincomplete;
      return undef;
    }
  }
  if ($uncompress) {
    return solv::xfopen_fd($file, POSIX::dup(fileno($f)));
  } else {
    return solv::xfopen_fd('', POSIX::dup(fileno($f)));
  }
}

sub usecachedrepo {
  my ($self, $ext, $mark) = @_;
  my $cookie = $ext ? $self->{'extcookie'} : $self->{'cookie'};
  my $handle = $self->{'handle'};
  my $cachepath = $self->cachepath();
  if (sysopen(my $f, $cachepath, POSIX::O_RDONLY)) {
    $f = solv::xfopen_fd('', POSIX::dup(fileno($f)));
    my $flags = $ext ? $solv::Repo::REPO_USE_LOADING|$solv::Repo::REPO_EXTEND_SOLVABLES : 0;
    $flags |= $solv::Repo::REPO_LOCALPOOL if $ext && $ext ne 'DL';
    if (!$self->{'handle'}->add_solv($f, $flags)) {
      solv::xfclose($f);
      return undef;
    }
    solv::xfclose($f);
    return 1;
  }
  return undef;
}

package Repo::rpmmd;

our @ISA = ('Repo::generic');

package Repo::susetags;

our @ISA = ('Repo::generic');

package Repo::unknown;

our @ISA = ('Repo::generic');

sub load {
  my ($self, $pool) = @_;
  print "unsupported repo '$self->{'alias'}': skipped\n";
  return 0;
}

package Repo::system;

our @ISA = ('Repo::generic');

sub calc_cookie_file {
  my ($self, $filename) = @_;
  my $chksum = solv::Chksum->new($solv::REPOKEY_TYPE_SHA256);
  $chksum->add("1.1");
  $chksum->add_stat($filename);
  return $chksum->raw();
}

sub load {
  my ($self, $pool) = @_;

  $self->{'handle'} = $pool->add_repo($self->{'alias'});
  $self->{'handle'}->{'appdata'} = $self;
  $pool->{'installed'} = $self->{'handle'};
  print "rpm database: ";
  $self->{'cookie'} = $self->calc_cookie_file('/var/lib/rpm/Packages');
  if ($self->usecachedrepo()) {
    print "cached\n";
    return 1;
  }
  return undef;
}

package main;

sub validarch {
  my ($pool, $arch) = @_;
  return undef unless $arch;
  my $id = $pool->str2id($arch, 0);
  return $id && $pool->isknownarch($id) ? 1 : undef;
}

sub depglob {
  my ($pool, $name, $globname, $globdep) = @_;
  my $id = $pool->str2id($name, 0);
  if ($id) {
    my $match;
    for my $s ($pool->providers($id)) {
      return $pool->Job($solv::Job::SOLVER_SOLVABLE_NAME, $id) if $globname && $s->{'nameid'} == $id;
      $match = 1;
    }
    if ($match) {
      print "[using capability match for '$name']\n" if $globname && $globdep;
      my @j = $pool->Job($solv::Job::SOLVER_SOLVABLE_PROVIDES, $id);
      return $pool->Job($solv::Job::SOLVER_SOLVABLE_PROVIDES, $id);
    }
  }
  return unless $name =~ /[[*?]/;
  if ($globname) {
    my %idmatches;
    for my $d (@{$pool->dataiterator_new(0, $solv::SOLVABLE_NAME, $name, $solv::Dataiterator::SEARCH_GLOB)}) {
      my $s = $d->{'solvable'};
      $idmatches{$s->{'nameid'}} = 1 if $s->installable();
    }
    if (%idmatches) {
      return map {$pool->Job($solv::Job::SOLVER_SOLVABLE_NAME, $_)} sort(keys %idmatches);
    }
  }
  if ($globdep) {
    my @idmatches = $pool->matchprovidingids($name, $solv::Dataiterator::SEARCH_GLOB);
    if (@idmatches) {
      print "[using capability match for '$name']\n";
      return map {$pool->Job($solv::Job::SOLVER_SOLVABLE_PROVIDES, $_)} sort(@idmatches);
    }
  }
  return;
}

sub limitjobs {
  my ($pool, $jobs, $flags, $evr) = @_;
  my @jobs;
  for my $j (@$jobs) {
    my $how = $j->{'how'};
    my $sel = $how & $solv::Job::SOLVER_SELECTMASK;
    my $what = $pool->rel2id($j->{'what'}, $evr, $flags);
    if ($flags == $solv::REL_ARCH) {
      $how |= $solv::Job::SOLVER_SETARCH;
    } elsif ($flags == $solv::REL_EQ && $sel == $solv::Job::SOLVER_SOLVABLE_NAME) {
      $how |= $pool->id2str($evr) =~ /-/ ? $solv::Job::SOLVER_SETEVR : $solv::Job::SOLVER_SETEV;
    }
    push @jobs, $pool->Job($how, $what);
  }
  return @jobs;
}

sub limitjobs_arch {
  my ($pool, $jobs, $flags, $evrstr) = @_;
  if ($evrstr =~ /^(.+)\.(.+?)$/ && validarch($pool, $2)) {
    my $evr = $pool->str2id($1);
    my @jobs = limitjobs($pool, $jobs, $solv::REL_ARCH, $pool->str2id($2));
    return limitjobs($pool, \@jobs, $flags, $evr);
  }
  return limitjobs($pool, $jobs, $flags, $pool->str2id($evrstr));
}

sub mkjobs_rel {
  my ($pool, $cmd, $name, $rel, $evr) = @_;
  my $flags = 0;
  $flags |= $solv::REL_LT if $rel =~ /</;
  $flags |= $solv::REL_EQ if $rel =~ /=/;
  $flags |= $solv::REL_GT if $rel =~ />/;
  my @jobs = depglob($pool, $name, 1, 1);
  return limitjobs($pool, \@jobs, $flags, $pool->str2id($evr)) if @jobs;
  if (($name =~ /^(.+)\.(.+?)$/s) && validarch($pool, $2)) {
    my $arch = $2;
    @jobs = depglob($pool, $1, 1, 1);
    if (@jobs) {
      @jobs = limitjobs($pool, \@jobs, $solv::REL_ARCH, $pool->str2id($arch));
      return limitjobs($pool, \@jobs, $flags, $pool->str2id($evr));
    }
  }
  return ();
}

sub mkjobs_nevra {
  my ($pool, $cmd, $arg) = @_;
  my @jobs = depglob($pool, $arg, 1, 1);
  return @jobs if @jobs;
  if (($arg =~ /^(.+)\.(.+?)$/s) && validarch($pool, $2)) {
    my $arch = $2;
    @jobs = depglob($pool, $1, 1, 1);
    return limitjobs($pool, \@jobs, $solv::REL_ARCH, $pool->str2id($arch)) if @jobs;
  }
  if ($arg =~ /^(.+)-(.+?)$/s) {
    my $evr = $2;
    @jobs = depglob($pool, $1, 1, 0);
    return limitjobs_arch($pool, \@jobs, $solv::REL_EQ, $evr) if @jobs;
  }
  if ($arg =~ /^(.+)-(.+?-.+?)$/s) {
    my $evr = $2;
    @jobs = depglob($pool, $1, 1, 0);
    return limitjobs_arch($pool, \@jobs, $solv::REL_EQ, $evr) if @jobs;
  }
  return ();
}

sub mkjobs_filelist {
  my ($pool, $cmd, $arg) = @_;
  my $type = ($arg =~ /[[*?]/) ? $solv::Dataiterator::SEARCH_GLOB : $solv::Dataiterator::SEARCH_STRING;
  $type |= $solv::Dataiterator::SEARCH_FILES | $solv::Dataiterator::SEARCH_COMPLETE_FILELIST;
  my $di;
  if ($cmd eq 'erase') {
    $di = $pool->{'installed'}->dataiterator_new(0, $solv::SOLVABLE_FILELIST, $arg, $type);
  } else {
    $di = $pool->dataiterator_new(0, $solv::SOLVABLE_FILELIST, $arg, $type);
  }
  my @matches;
  for my $d (@$di) {
    my $s = $d->{'solvable'};
    next unless $s && $s->installable();
    push @matches, $s->{'id'};
    tied(@$di)->iter()->skip_solvable();
  }
  return () unless @matches;
  print "[using file list match for '$arg']\n";
  if (@matches > 1) {
    return $pool->Job($solv::Job::SOLVER_SOLVABLE_ONE_OF, $pool->towhatprovides(\@matches));
  } else {
    return $pool->Job($solv::Job::SOLVER_SOLVABLE | $solv::Job::SOLVER_NOAUTOSET, $matches[0]);
  }
}

sub mkjobs {
  my ($pool, $cmd, $arg) = @_;
  if ($arg && $arg =~ /^\//) {
    my @jobs = mkjobs_filelist($pool, $cmd, $arg);
    return @jobs if @jobs;
  }
  if ($arg =~ /^(.+?)\s*([<=>]+)\s*(.+?)$/s) {
    return mkjobs_rel($pool, $cmd, $1, $2, $3);
  } else {
    return mkjobs_nevra($pool, $cmd, $arg);
  }
}

die("Usage: p5solv COMMAND [ARGS]\n") unless @ARGV;
my $cmd = shift @ARGV;
$cmd = 'list' if $cmd eq 'li';
$cmd = 'install' if $cmd eq 'in';
$cmd = 'erase' if $cmd eq 'rm';
$cmd = 'verify' if $cmd eq 've';
$cmd = 'search' if $cmd eq 'se';

my $pool = solv::Pool->new();
$pool->setarch((POSIX::uname())[4]);
my @repos;
for my $reposdir ('/etc/zypp/repos.d') {
  next unless -d $reposdir;
  next unless opendir(DIR, $reposdir);
  for my $reponame (sort(grep {/\.repo$/} readdir(DIR))) {
    my $cfg = new Config::IniFiles('-file' => "$reposdir/$reponame");
    for my $alias ($cfg->Sections()) {
      my $repoattr = {'alias' => $alias, 'enabled' => 0, 'priority' => 99, 'autorefresh' => 1, 'type' => 'rpm-md', 'metadata_expire' => 900};
      for my $p ($cfg->Parameters($alias)) {
	$repoattr->{$p} = $cfg->val($alias, $p);
      }
      my $repo;
      if ($repoattr->{'type'} eq 'rpm-md') {
	$repo = Repo::rpmmd->new($repoattr);
      } elsif ($repoattr->{'type'} eq 'yast2') {
	$repo = Repo::susetags->new($repoattr);
      } else {
	$repo = Repo::unknown->new($repoattr);
      }
      push @repos, $repo;
    }
  }
}

my $sysrepo = Repo::system->new({'alias' => '@System', 'type' => 'system'});
$sysrepo->load($pool);
for my $repo (@repos) {
  $repo->load($pool) if $repo->{'enabled'};
}

if ($cmd eq 'search') {
  my %matches;
  my $di = $pool->dataiterator_new(0, $solv::SOLVABLE_NAME, $ARGV[0], $solv::Dataiterator::SEARCH_SUBSTRING | $solv::Dataiterator::SEARCH_NOCASE);
  for my $d (@$di) {
    $matches{$d->{'solvid'}} = 1;
  }
  for my $solvid (sort keys %matches) {
    my $s = $pool->{'solvables'}->[$solvid];
    print "- ".$s->str()." [$s->{'repo'}->{'name'}] ".$s->lookup_str($solv::SOLVABLE_SUMMARY)."\n";
  }
  exit(0);
}

my @addedprovides =  $pool->addfileprovides_ids();
$pool->createwhatprovides();

my @jobs;
for my $arg (@ARGV) {
  my @njobs = mkjobs($pool, $cmd, $arg);
  die("nothing matches '$arg'\n") unless @njobs;
  push @jobs, @njobs;
}

if ($cmd eq 'list' || $cmd eq 'info') {
  die("no package matched.\n") unless @jobs;
  for my $job (@jobs) {
    for my $s ($pool->jobsolvables($job)) {
      if ($cmd eq 'info') {
        printf "Name:        %s\n", $s->str();
        printf "Repo:        %s\n", $s->{'repo'}->{'name'};
        printf "Summary:     %s\n", $s->lookup_str($solv::SOLVABLE_SUMMARY);
	my $str = $s->lookup_str($solv::SOLVABLE_URL);
        printf "Url:         %s\n", $str if $str;
	$str = $s->lookup_str($solv::SOLVABLE_LICENSE);
        printf "License:     %s\n", $str if $str;
        printf "Description:\n%s\n", $s->lookup_str($solv::SOLVABLE_DESCRIPTION);
      } else {
        printf "  - %s [%s]\n", $s->str(), $s->{'repo'}->{'name'};
        printf "    %s\n", $s->lookup_str($solv::SOLVABLE_SUMMARY);
      }
    }
  }
  exit 0;
}

if ($cmd eq 'install' || $cmd eq 'erase' || $cmd eq 'up' || $cmd eq 'dup' || $cmd eq 'verify') {
  if (!@jobs) {
    if ($cmd eq 'up' || $cmd eq 'verify') {
      push @jobs, $pool->Job($solv::Job::SOLVER_SOLVABLE_ALL, 0);
    } elsif ($cmd ne 'dup') {
      die("no package matched.\n");
    }
  }
  for my $job (@jobs) {
    if ($cmd eq 'up') {
      if ($job->{'how'} == $solv::Job::SOLVER_SOLVABLE_ALL || grep {$_->isinstalled()} $pool->jobsolvables($job)) {
        $job->{'how'} |= $solv::Job::SOLVER_UPDATE;
      } else {
        $job->{'how'} |= $solv::Job::SOLVER_INSTALL;
      }
    } elsif ($cmd eq 'install') {
        $job->{'how'} |= $solv::Job::SOLVER_INSTALL;
    } elsif ($cmd eq 'erase') {
        $job->{'how'} |= $solv::Job::SOLVER_ERASE;
    } elsif ($cmd eq 'dup') {
        $job->{'how'} |= $solv::Job::SOLVER_DISTUPGRADE;
    } elsif ($cmd eq 'verify') {
        $job->{'how'} |= $solv::Job::SOLVER_VERIFY;
    }
  }
  my $solver;
  while (1) {
    $solver = $pool->create_solver();
    $solver->{'ignorealreadyrecommended'} = 1;
    $solver->{'allowuninstall'} = 1 if $cmd eq 'erase';
    if ($cmd eq 'dup' && !@jobs) {
      $solver->{'distupgrade'} = 1;
      $solver->{'updatesystem'} = 1;
      $solver->{'allowdowngrade'} = 1;
      $solver->{'allowvendorchange'} = 1;
      $solver->{'allowarchchange'} = 1;
      $solver->{'dosplitprovides'} = 1;
    } elsif ($cmd eq 'up' and @jobs == 1 and $jobs[0]->{'how'} == ($solv::Job::SOLVER_UPDATE | $solv::Job::SOLVER_SOLVABLE_ALL)) {
      $solver->{'dosplitprovides'} = 1;
    }
    my @problems = $solver->solve(\@jobs);
    last unless @problems;
    for my $problem (@problems) {
      print "Problem $problem->{'id'}/".@problems.":\n";
      my $r = $problem->findproblemrule();
      my $ri = $r->info();
      print $ri->problemstr()."\n";
      my @solutions = $problem->solutions();
      for my $solution (@solutions) {
	print "  Solution $solution->{'id'}:\n";
	for my $element ($solution->elements()) {
	  my $etype = $element->{'type'};
	  if ($etype == $solv::Solver::SOLVER_SOLUTION_JOB) {
	    print "  - do not ask to ".$jobs[$element->{'jobidx'}]->str()."\n";
	  } elsif ($etype == $solv::Solver::SOLVER_SOLUTION_INFARCH) {
	    if ($element->{'solvable'}->isinstalled()) {
	      print "  - keep ".$element->{'solvable'}->str()." despite the inferior architecture\n";
	    } else {
	      print "  - install ".$element->{'solvable'}->str()." despite the inferior architecture\n";
	    }
	  } elsif ($etype == $solv::Solver::SOLVER_SOLUTION_DISTUPGRADE) {
	    if ($element->{'solvable'}->isinstalled()) {
	      print "  - keep obsolete ".$element->{'solvable'}->str()."\n";
	    } else {
	      print "  - install ".$element->{'solvable'}->str()." from excluded repository\n";
	    }
	  } elsif ($etype == $solv::Solver::SOLVER_SOLUTION_REPLACE) {
	    print "  - allow replacement of ".$element->{'solvable'}->str()." with ".$element->{'replacement'}->str()."\n";
	  } elsif ($etype == $solv::Solver::SOLVER_SOLUTION_ERASE) {
	    print "  - allow deinstallation of ".$element->{'solvable'}->str()."\n";
	  } else {
	    print "  - allow something else\n";
	  }
        }
      }
      my $sol;
      while (1) {
	print "Please choose a solution: ";
	$sol = <STDIN>;
	chomp $sol;
	last if $sol eq 's' || $sol eq 'q' || ($sol =~ /^\d+$/ && $sol >= 1 && $sol <= @solutions);
      }
      next if $sol eq 's';
      exit(1) if $sol eq 'q';
      my $solution = $solutions[$sol - 1];
      for my $element ($solution->elements()) {
        my $etype = $element->{'type'};
        if ($etype == $solv::Solver::SOLVER_SOLUTION_JOB) {
	  $jobs[$element->{'jobidx'}] = $pool->Job($solv::Job::SOLVER_NOOP, 0);
        } else {
	  my $newjob = $element->Job();
	  push @jobs, $newjob if $newjob && !grep {$_->{'how'} == $newjob->{'how'} && $_->{'what'} == $newjob->{'what'}} @jobs;
	}
      }
    }
  }
  my $trans = $solver->transaction();
  undef $solver;
  if ($trans->isempty()) {
    print "Nothing to do.\n";
    exit 0;
  }
  print "\nTransaction summary:\n\n";
  for my $c ($trans->classify()) {
    my ($ctype, $pkgs, $fromid, $toid) = @$c;
    if ($ctype == $solv::Transaction::SOLVER_TRANSACTION_ERASE) {
      printf "%d erased packages:\n", scalar(@$pkgs);
    } elsif ($ctype == $solv::Transaction::SOLVER_TRANSACTION_INSTALL) {
      printf "%d installed packages:\n", scalar(@$pkgs);
    } elsif ($ctype == $solv::Transaction::SOLVER_TRANSACTION_REINSTALLED) {
      printf "%d reinstalled packages:\n", scalar(@$pkgs);
    } elsif ($ctype == $solv::Transaction::SOLVER_TRANSACTION_DOWNGRADED) {
      printf "%d downgraded packages:\n", scalar(@$pkgs);
    } elsif ($ctype == $solv::Transaction::SOLVER_TRANSACTION_CHANGED) {
      printf "%d changed packages:\n", scalar(@$pkgs);
    } elsif ($ctype == $solv::Transaction::SOLVER_TRANSACTION_UPGRADED) {
      printf "%d upgraded packages:\n", scalar(@$pkgs);
    } elsif ($ctype == $solv::Transaction::SOLVER_TRANSACTION_VENDORCHANGE) {
      printf "%d vendor changes from '%s' to '%s':\n", scalar(@$pkgs), $pool->id2str($fromid), $pool->id2str($toid);
    } elsif ($ctype == $solv::Transaction::SOLVER_TRANSACTION_ARCHCHANGE) {
      printf "%d arch changes from '%s' to '%s':\n", scalar(@$pkgs), $pool->id2str($fromid), $pool->id2str($toid);
    } else {
      next;
    }
    for my $p (@$pkgs) {
      if ($ctype == $solv::Transaction::SOLVER_TRANSACTION_UPGRADED || $ctype == $solv::Transaction::SOLVER_TRANSACTION_DOWNGRADED) {
	my $other = $trans->othersolvable($p);
	printf "  - %s -> %s\n", $p->str(), $other->str();
      } else {
	printf "  - %s\n", $p->str();
      }
    }
    print "\n";
  }
  printf "install size change: %d K\n\n", $trans->calc_installsizechange();
  while (1) {
    print("OK to continue (y/n)? ");
    my $yn = <STDIN>;
    chomp $yn;
    last if $yn eq 'y';
    exit(1) if $yn eq 'n';
  }
  my @newpkgs = $trans->newpackages();
  my %newpkgsfps;
  if (@newpkgs) {
    my $downloadsize = 0;
    $downloadsize += $_->lookup_num($solv::SOLVABLE_DOWNLOADSIZE) for @newpkgs;
    printf "Downloading %d packages, %d K\n", scalar(@newpkgs), $downloadsize;
    for my $p (@newpkgs) {
      my $repo = $p->{'repo'}->{'appdata'};
      my ($location, $medianr) = $p->lookup_location();
      next unless $location;
      if ($repo->{'type'} eq 'yast2') {
	$location = ($repo->{'handle'}->lookup_str($solv::SOLVID_META, $solv::SUSETAGS_DATADIR) || 'suse') ."/$location";
      }
      my $chksum = $p->lookup_checksum($solv::SOLVABLE_CHECKSUM);
      my $f = $repo->download($location, 0, $chksum);
      die("\n$repo->{'alias'}: $location not found in repository\n") unless $f;
      $newpkgsfps{$p->{'id'}} = $f;
      print ".";
      STDOUT->flush();
    }
    print "\n";
  }
  print "Committing transaction:\n\n";
  $trans->order(0);
  for my $p ($trans->steps()) {
    my $steptype = $trans->steptype($p, $solv::Transaction::SOLVER_TRANSACTION_RPM_ONLY);
    if ($steptype == $solv::Transaction::SOLVER_TRANSACTION_ERASE) {
      print "erase ".$p->str()."\n";
      next unless $p->lookup_num($solv::RPM_RPMDBID);
      my $evr = $p->{'evr'};
      $evr =~ s/^[0-9]+://;	# strip epoch
      system('rpm', '-e', '--nodeps', '--nodigest', '--nosignature', "$p->{'name'}-$evr.$p->{'arch'}") && die("rpm failed: $?\n");
    } elsif ($steptype == $solv::Transaction::SOLVER_TRANSACTION_INSTALL || $steptype == $solv::Transaction::SOLVER_TRANSACTION_MULTIINSTALL) {
      print "install ".$p->str()."\n";
      my $f = $newpkgsfps{$p->{'id'}};
      my $mode = $steptype == $solv::Transaction::SOLVER_TRANSACTION_INSTALL ? '-U' : '-i';
      system('rpm', $mode, '--force', '--nodeps', '--nodigest', '--nosignature', "/dev/fd/".solv::xfileno($f)) && die("rpm failed: $?\n");
      solv::xfclose($f);
      delete $newpkgsfps{$p->{'id'}};
    }
  }
}

exit 0;
