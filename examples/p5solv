#!/usr/bin/perl

use POSIX;
use Config::IniFiles;
use File::FnMatch;
use Data::Dumper;
use solv;
use strict;

package Repo::generic;

sub new {
  my ($class, $attr) = @_;
  my $r = { %$attr };
  return bless $r, $class;
}

sub cachepath {
  my ($self, $ext) = @_;
  my $path = $self->{'alias'};
  $path =~ s/^\./_/s;
  $path .= $ext ? "_$ext.solvx" : '.solv';
  $path =~ s/\//_/gs;
  return "/var/cache/solv/$path";
}

sub load {
  my ($self, $pool) = @_;
  $self->{'handle'} = $pool->add_repo($self->{'alias'});
  $self->{'handle'}->{'appdata'} = $self;
  $self->{'handle'}->{'priority'} = 99 - $self->{'priority'};
  $self->{'cookie'} = '';
  $self->usecachedrepo();
}

sub usecachedrepo {
  my ($self, $ext, $mark) = @_;
  my $cookie = $ext ? $self->{'extcookie'} : $self->{'cookie'};
  my $handle = $self->{'handle'};
  my $cachepath = $self->cachepath();
  if (sysopen(my $f, $cachepath, POSIX::O_RDONLY)) {
    $f = solv::xfopen_fd('', POSIX::dup(fileno($f)));
    my $flags = $ext ? $solv::Repo::REPO_USE_LOADING|$solv::Repo::REPO_EXTEND_SOLVABLES : 0;
    $flags |= $solv::Repo::REPO_LOCALPOOL if $ext && $ext ne 'DL';
    if (!$self->{'handle'}->add_solv($f, $flags)) {
      solv::xfclose($f);
      return undef;
    }
    return 1;
  }
  return undef;
}

package Repo::rpmmd;

our @ISA = ('Repo::generic');

package Repo::system;

our @ISA = ('Repo::generic');

sub calc_cookie_file {
  my ($self, $filename) = @_;
  my $chksum = solv::Chksum->new($solv::REPOKEY_TYPE_SHA256);
  $chksum->add("1.1");
  $chksum->add_stat($filename);
  return $chksum->raw();
}

sub load {
  my ($self, $pool) = @_;

  $self->{'handle'} = $pool->add_repo($self->{'alias'});
  $self->{'handle'}->{'appdata'} = $self;
  $pool->{'installed'} = $self->{'handle'};
  print "rpm database: ";
  $self->{'cookie'} = $self->calc_cookie_file('/var/lib/rpm/Packages');
  if ($self->usecachedrepo()) {
    print "cached\n";
    return 1;
  }
  return undef;
}

package main;

sub validarch {
  my ($pool, $arch) = @_;
  return undef unless $arch;
  my $id = $pool->str2id($arch, 0);
  return $id && $pool->isknownarch($id) ? 1 : undef;
}

sub depglob {
  my ($pool, $name, $globname, $globdep) = @_;
  my $id = $pool->str2id($name, 0);
  if ($id) {
    my $match;
    for my $s ($pool->providers($id)) {
      return $pool->Job($solv::Job::SOLVER_SOLVABLE_NAME, $id) if $globname && $s->{'nameid'} == $id;
      $match = 1;
    }
    if ($match) {
      print "[using capability match for '$name']\n" if $globname && $globdep;
      my @j = $pool->Job($solv::Job::SOLVER_SOLVABLE_PROVIDES, $id);
      return $pool->Job($solv::Job::SOLVER_SOLVABLE_PROVIDES, $id);
    }
  }
  return unless $name =~ /[[*?]/;
  if ($globname) {
    my %idmatches;
    for my $s (@{$pool->{'solvables_iter'}}) {
      $idmatches{$s->{'nameid'}} = 1 if $s->installable() && File::FnMatch::fnmatch($name, $s->{'name'}, 0);
    }
    if (%idmatches) {
      return map {$pool->Job($solv::Job::SOLVER_SOLVABLE_NAME, $_)} sort(keys %idmatches);
    }
  }
  if ($globdep) {
    my %idmatches;
    for $id (@{$pool->allprovidingids()}) {
      $idmatches{$id} = 1 if File::FnMatch::fnmatch($name, $pool->id2str($id), 0);
    }
    if (%idmatches) {
      print "[using capability match for '$name']\n";
      return map {$pool->Job($solv::Job::SOLVER_SOLVABLE_PROVIDES, $_)} sort(keys %idmatches);
    }
  }
  return;
}

sub limitjobs {
  my ($pool, $jobs, $flags, $evr) = @_;
  my @jobs;
  for my $j (@$jobs) {
    my $how = $j->{'how'};
    my $sel = $how & $solv::Job::SOLVER_SELECTMASK;
    my $what = $pool->rel2id($j->{'what'}, $evr, $flags);
    if ($flags == $solv::REL_ARCH) {
      $how |= $solv::Job::SOLVER_SETARCH;
    } elsif ($flags == $solv::REL_EQ && $sel == $solv::Job::SOLVER_SOLVABLE_NAME) {
      $how |= $pool->id2str($evr) =~ /-/ ? $solv::Job::SOLVER_SETEVR : $solv::Job::SOLVER_SETEV;
    }
    push @jobs, $pool->Job($how, $what);
  }
  return @jobs;
}

sub limitjobs_arch {
  my ($pool, $jobs, $flags, $evrstr) = @_;
  if ($evrstr =~ /^(.+)\.(.+?)$/ && validarch($pool, $2)) {
    my $evr = $pool->str2id($1);
    my @jobs = limitjobs($pool, $jobs, $solv::solv::REL_ARCH, $pool->str2id($2));
    return limitjobs($pool, \@jobs, $flags, $evr);
  }
  return limitjobs($pool, $jobs, $flags, $pool->str2id($evrstr));
}

sub mkjobs_rel {
  my ($pool, $cmd, $name, $rel, $evr) = @_;
  my $flags = 0;
  $flags |= $solv::REL_LT if $rel =~ /</;
  $flags |= $solv::REL_EQ if $rel =~ /=/;
  $flags |= $solv::REL_GT if $rel =~ />/;
  my @jobs = depglob($pool, $name, 1, 1);
  return limitjobs($pool, \@jobs, $flags, $pool->str2id($evr)) if @jobs;
  if (($name =~ /^(.+)\.(.+?)$/s) && validarch($pool, $2)) {
    my $arch = $2;
    @jobs = depglob($pool, $1, 1, 1);
    if (@jobs) {
      @jobs = limitjobs($pool, \@jobs, $solv::solv::REL_ARCH, $pool->str2id($arch));
      return limitjobs($pool, \@jobs, $flags, $pool->str2id($evr));
    }
  }
  return ();
}

sub mkjobs_nevra {
  my ($pool, $cmd, $arg) = @_;
  my @jobs = depglob($pool, $arg, 1, 1);
  return @jobs if @jobs;
  if (($arg =~ /^(.+)\.(.+?)$/s) && validarch($pool, $2)) {
    my $arch = $2;
    @jobs = depglob($pool, $1, 1, 1);
    return limitjobs($pool, \@jobs, $solv::REL_ARCH, $pool->str2id($arch)) if @jobs;
  }
  if ($arg =~ /^(.+)-(.+?)$/s) {
    my $evr = $2;
    @jobs = depglob($pool, $1, 1, 0);
    return limitjobs_arch($pool, \@jobs, $solv::REL_EQ, $evr) if @jobs;
  }
  if ($arg =~ /^(.+)-(.+?-.+?)$/s) {
    my $evr = $2;
    @jobs = depglob($pool, $1, 1, 0);
    return limitjobs_arch($pool, \@jobs, $solv::REL_EQ, $evr) if @jobs;
  }
  return ();
}

sub mkjobs_filelist {
  my ($pool, $cmd, $arg) = @_;
  my $type = ($arg =~ /[[*?]/) ? $solv::Dataiterator::SEARCH_GLOB : $solv::Dataiterator::SEARCH_STRING;
  $type |= $solv::Dataiterator::SEARCH_FILES | $solv::Dataiterator::SEARCH_COMPLETE_FILELIST;
  my $di;
  if ($cmd eq 'erase') {
    $di = $pool->{'installed'}->dataiterator_new(0, $solv::SOLVABLE_FILELIST, $arg, $type);
  } else {
    $di = $pool->dataiterator_new(0, $solv::SOLVABLE_FILELIST, $arg, $type);
  }
  my @matches;
  for my $d (@$di) {
    my $s = $d->{'solvable'};
    next unless $s && $s->installable();
    push @matches, $s->{'id'};
    tied(@$di)->iter()->skip_solvable();
  }
  return () unless @matches;
  print "[using file list match for '$arg']\n";
  if (@matches > 1) {
    return $pool->Job($solv::Job::SOLVER_SOLVABLE_ONE_OF, $pool->towhatprovides(\@matches));
  } else {
    return $pool->Job($solv::Job::SOLVER_SOLVABLE | $solv::Job::NOAUTOSET, $matches[0]);
  }
}

sub mkjobs {
  my ($pool, $cmd, $arg) = @_;
  if ($arg && $arg =~ /^\//) {
    my @jobs = mkjobs_filelist($pool, $cmd, $arg);
    return @jobs if @jobs;
  }
  if ($arg =~ /^(.+?)\s*([<=>]+)\s*(.+?)$/s) {
    return mkjobs_rel($pool, $cmd, $1, $2, $3);
  } else {
    return mkjobs_nevra($pool, $cmd, $arg);
  }
}

die("Usage: p5solv COMMAND [ARGS]\n") unless @ARGV;
my $cmd = shift @ARGV;
$cmd = 'list' if $cmd eq 'li';
$cmd = 'install' if $cmd eq 'in';
$cmd = 'erase' if $cmd eq 'rm';
$cmd = 'verify' if $cmd eq 've';
$cmd = 'search' if $cmd eq 'se';

my $pool = solv::Pool->new();
$pool->setarch((POSIX::uname())[4]);
my @repos;
for my $reposdir ('/etc/zypp/repos.d') {
  next unless -d $reposdir;
  next unless opendir(DIR, $reposdir);
  for my $reponame (sort(grep {/\.repo$/} readdir(DIR))) {
    my $cfg = new Config::IniFiles('-file' => "$reposdir/$reponame");
    for my $alias ($cfg->Sections()) {
      my $repoattr = {'alias' => $alias, 'enabled' => 0, 'priority' => 99, 'autorefresh' => 1, 'type' => 'rpm-md', 'metadata_expire' => 900};
      for my $p ($cfg->Parameters($alias)) {
	$repoattr->{$p} = $cfg->val($alias, $p);
      }
      my $repo;
      if ($repoattr->{'type'} == 'rpm-md') {
	$repo = Repo::rpmmd->new($repoattr);
      }
      push @repos, $repo;
    }
  }
}

my $sysrepo = Repo::system->new({'alias' => '@System', 'type' => 'system'});
$sysrepo->load($pool);
for my $repo (@repos) {
  $repo->load($pool) if $repo->{'enabled'};
}

if ($cmd eq 'search') {
  my %matches;
  my $di = $pool->dataiterator_new(0, $solv::SOLVABLE_NAME, $ARGV[0], $solv::Dataiterator::SEARCH_SUBSTRING | $solv::Dataiterator::SEARCH_NOCASE);
  for my $d (@$di) {
    $matches{$d->{'solvid'}} = 1;
  }
  for my $solvid (sort keys %matches) {
    my $s = $pool->{'solvables'}->[$solvid];
    print "- ".$s->str()." [$s->{'repo'}->{'name'}] ".$s->lookup_str($solv::SOLVABLE_SUMMARY)."\n";
  }
  exit(0);
}

my $addedprovides =  $pool->addfileprovides_ids();
$pool->createwhatprovides();

my @jobs;
for my $arg (@ARGV) {
  my @njobs = mkjobs($pool, $cmd, $arg);
  die("nothing matches '$arg'\n") unless @njobs;
  push @jobs, @njobs;
}

if ($cmd eq 'list' || $cmd eq 'info') {
  die("no package matched.\n") unless @jobs;
  for my $job (@jobs) {
    for my $s ($pool->jobsolvables($job)) {
      if ($cmd eq 'info') {
        printf "Name:        %s\n", $s->str();
        printf "Repo:        %s\n", $s->{'repo'}->{'name'};
        printf "Summary:     %s\n", $s->lookup_str($solv::SOLVABLE_SUMMARY);
	my $str = $s->lookup_str($solv::SOLVABLE_URL);
        printf "Url:         %s\n", $str if $str;
	my $str = $s->lookup_str($solv::SOLVABLE_LICENSE);
        printf "License:     %s\n", $str if $str;
        printf "Description:\n%s\n", $s->lookup_str($solv::SOLVABLE_DESCRIPTION);
      } else {
        printf "  - %s [%s]\n", $s->str(), $s->{'repo'}->{'name'};
        printf "    %s\n", $s->lookup_str($solv::SOLVABLE_SUMMARY);
      }
    }
  }
  exit 0;
}

if ($cmd eq 'install' || $cmd eq 'erase' || $cmd eq 'up' || $cmd eq 'dup' || $cmd eq 'verify') {
  if (!@jobs) {
    if ($cmd eq 'up' || $cmd eq 'verify') {
      push @jobs, $pool->Job($solv::Job::SOLVER_SOLVABLE_ALL, 0);
    } elsif ($cmd ne 'dup') {
      die("no package matched.\n");
    }
  }
  for my $job (@jobs) {
    if ($cmd eq 'up') {
      if ($job->{'how'} == $solv::Job::SOLVER_SOLVABLE_ALL || grep {$_->isinstalled()} @{$pool->jobsolvables($job)}) {
        $job->{'how'} |= $solv::Job::SOLVER_UPDATE;
      } else {
        $job->{'how'} |= $solv::Job::SOLVER_INSTALL;
      }
    } elsif ($cmd eq 'install') {
        $job->{'how'} |= $solv::Job::SOLVER_INSTALL;
    } elsif ($cmd eq 'erase') {
        $job->{'how'} |= $solv::Job::SOLVER_ERASE;
    } elsif ($cmd eq 'dup') {
        $job->{'how'} |= $solv::Job::SOLVER_DISTUPGRADE;
    } elsif ($cmd eq 'verify') {
        $job->{'how'} |= $solv::Job::SOLVER_VERIFY;
    }
  }
  my $solver;
  while (1) {
    $solver = $pool->create_solver();
    $solver->{'ignorealreadyrecommended'} = 1;
    $solver->{'allowuninstall'} = 1 if $cmd eq 'erase';
    if ($cmd eq 'dup' && !@jobs) {
      $solver->{'distupgrade'} = 1;
      $solver->{'updatesystem'} = 1;
      $solver->{'allowdowngrade'} = 1;
      $solver->{'allowvendorchange'} = 1;
      $solver->{'allowarchchange'} = 1;
      $solver->{'dosplitprovides'} = 1;
    } elsif ($cmd eq 'up' and @jobs == 1 and $jobs[0]->{'how'} == ($solv::Job::SOLVER_UPDATE | $solv::Job::SOLVER_SOLVABLE_ALL)) {
      $solver->{'dosplitprovides'} = 1;
    }
    my @problems = $solver->solve(\@jobs);
    last unless @problems;
    for my $problem (@problems) {
      print "Problem $problem->{'id'}:\n";
      my $r = $problem->findproblemrule();
      my ($type, $source, $target, $dep) = $r->info();
      if ($type == $solv::Solver::SOLVER_RULE_RPM_PACKAGE_CONFLICT) {
        printf "package %s conflicts with %s provided by %s\n", $source->str(), $pool->dep2str($dep), $target->str();
      }
      print "TYPE: $type\n";
      printf "SOURCE: %s\n", $source->str() if $source;
      printf "TARGET: %s\n", $target->str() if $target;
      printf "DEP: %s\n", $pool->dep2str($dep) if $dep;
    }
    exit(0);
  }
}

exit 0;
